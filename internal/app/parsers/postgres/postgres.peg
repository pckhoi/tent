{
    // Package postgres parses SQL dump files produced pgdump command
    package postgres

    func toIfaceSlice(v interface{}) []interface{} {
        if v == nil {
            return nil
        }
        return v.([]interface{})
    }

    func toByteSlice(v interface{}) []byte {
        valsSl := toIfaceSlice(v)
        var result []byte
        for _, val := range valsSl {
            result = append(result, val.([]byte)[0])
        }
        return result
    }
}

SQL <- stmts:Stmt+ {
    return stmts, nil
}

Stmt <- Comment* _ stmt:( SetStmt / CreateTableStmt / CreateExtensionStmt / CommentExtensionStmt ) {
    return stmt, nil
}


/*
 ██████╗██████╗ ███████╗ █████╗ ████████╗███████╗    ████████╗ █████╗ ██████╗ ██╗     ███████╗
██╔════╝██╔══██╗██╔════╝██╔══██╗╚══██╔══╝██╔════╝    ╚══██╔══╝██╔══██╗██╔══██╗██║     ██╔════╝
██║     ██████╔╝█████╗  ███████║   ██║   █████╗         ██║   ███████║██████╔╝██║     █████╗  
██║     ██╔══██╗██╔══╝  ██╔══██║   ██║   ██╔══╝         ██║   ██╔══██║██╔══██╗██║     ██╔══╝  
╚██████╗██║  ██║███████╗██║  ██║   ██║   ███████╗       ██║   ██║  ██║██████╔╝███████╗███████╗
 ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝   ╚═╝   ╚══════╝       ╚═╝   ╚═╝  ╚═╝╚═════╝ ╚══════╝╚══════╝
*/                                                                                            

CreateTableStmt <- "CREATE"i _1 "TABLE"i _1 tablename:Ident _ "(" _ fields:( FieldDef ( _ "," _ FieldDef )* ) _ ")" _ ";" EOL {
    fieldsSlice := []map[string]string{}
    valsSlice := toIfaceSlice(fields)
    fieldsSlice = append(fieldsSlice, valsSlice[0].(map[string]string))
    restSlice := toIfaceSlice(valsSlice[1])
    for _, v := range restSlice {
        vSlice := toIfaceSlice(v)
        fieldsSlice = append(fieldsSlice, vSlice[3].(map[string]string))
    }
    return parseCreateTableStmt(tablename, fieldsSlice), nil
}

FieldDef <- name:Ident _1 dataType:DataType notnull:( _1 "NOT"i _1 "NULL"i )? {
    result := dataType.(map[string]string)
    result["name"] = interfaceToString(name)
    if notnull != nil {
        result["not_null"] = "true"
    }
    return result, nil
}

DataType <- t:( TimestampT / TimeT / OtherT ) {
    return t, nil
}

TimestampT <- "timestamp" prec:SecPrecision withTimeZone:( WithTZ / WithoutTZ )? {
    var result = make(map[string]string)
    if withTimeZone.(bool) {
        result["type"] = "datetimetz"
    } else {
        result["type"] = "datetime"
    }
    if prec != nil {
        result["sec_precision"] = prec.(string)
    }
    return result, nil
}

TimeT <- "time" prec:SecPrecision withTimeZone:( WithTZ / WithoutTZ )? {
    var result = make(map[string]string)
    if withTimeZone.(bool) {
        result["type"] = "timetz"
    } else {
        result["type"] = "time"
    }
    if prec != nil {
        result["sec_precision"] = prec.(string)
    }
    return result, nil
}

SecPrecision <- ( _1 [0-6])? {
    if len(c.text) > 0 {
        return strings.TrimLeft(string(c.text), " \r\t\n"), nil
    }
    return nil, nil
}

WithTZ <- _1 "with" _1 "time" _1 "zone" {
    return true, nil
}

WithoutTZ <- ( _1 "without" _1 "time" _1 "zone" )? {
    return false, nil
}

OtherT <- ( "date" / "integer" / "smallint" / "bigint" / "decimal" / "numeric" / "real" / "smallserial" / "serial" / "bigserial" / "boolean" ) {
    return map[string]string{
        "type": string(c.text),
    }, nil
}


/*
 ██████╗ ████████╗██╗  ██╗███████╗██████╗     ███████╗████████╗███╗   ███╗████████╗
██╔═══██╗╚══██╔══╝██║  ██║██╔════╝██╔══██╗    ██╔════╝╚══██╔══╝████╗ ████║╚══██╔══╝
██║   ██║   ██║   ███████║█████╗  ██████╔╝    ███████╗   ██║   ██╔████╔██║   ██║   
██║   ██║   ██║   ██╔══██║██╔══╝  ██╔══██╗    ╚════██║   ██║   ██║╚██╔╝██║   ██║   
╚██████╔╝   ██║   ██║  ██║███████╗██║  ██║    ███████║   ██║   ██║ ╚═╝ ██║   ██║   
 ╚═════╝    ╚═╝   ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝    ╚══════╝   ╚═╝   ╚═╝     ╚═╝   ╚═╝   
*/

CommentExtensionStmt <- "COMMENT"i _1 "ON"i _1 "EXTENSION"i _ extension:Ident _ "IS"i _ comment:StringConst _ `;` EOL {
    return parseCommentExtensionStmt(extension.(Identifier), comment.(String)), nil
}

CreateExtensionStmt <- "CREATE"i _1 "EXTENSION"i _1 ( "IF"i _1 "NOT"i _1 "EXISTS"i _1 )? extension:Ident _1 "WITH"i _1 "SCHEMA"i _1 schema:Ident _ `;` EOL {
    return parseCreateExtensionStmt(extension.(Identifier), schema.(Identifier)), nil
}

SetStmt <- "SET"i _ key:Key _ ( `=` / "TO"i ) _ values:CommaSeparatedValues _ `;` EOL {
    updateSettings(key.(string), toIfaceSlice(values))
    return nil, nil
}

Key <- [a-z_]i+ {
    return string(c.text), nil
}


/*
██╗   ██╗ █████╗ ██╗     ██╗   ██╗███████╗███████╗
██║   ██║██╔══██╗██║     ██║   ██║██╔════╝██╔════╝
██║   ██║███████║██║     ██║   ██║█████╗  ███████╗
╚██╗ ██╔╝██╔══██║██║     ██║   ██║██╔══╝  ╚════██║
 ╚████╔╝ ██║  ██║███████╗╚██████╔╝███████╗███████║
  ╚═══╝  ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚══════╝╚══════╝
*/


CommaSeparatedValues <- vals:( Value ( _ ',' _ Value )* ) {
    res := []interface{}{}
    valsSlice := toIfaceSlice(vals)
    res = append(res, valsSlice[0])
    restSlice := toIfaceSlice(valsSlice[1])
    for _, v := range restSlice {
        vSlice := toIfaceSlice(v)
        res = append(res, vSlice[3])
    }
    return res, nil
}

Value <- ( Number / Boolean / StringConst / Ident )

StringConst <- `'` value:[^'\n]* `'` {
    return String(toByteSlice(value)), nil
}

Ident <- [a-z_]i [a-z_0-9$]i* {
    return Identifier(c.text), nil
}

Number <- ( `0` / [1-9][0-9]* ) {
    number, _ := strconv.ParseInt(string(c.text), 10, 64)
    return number, nil
}

Boolean <- value:( BooleanTrue / BooleanFalse ) {
    return value, nil
}

BooleanTrue <- ( "TRUE" / "'" BooleanTrueString "'" / BooleanTrueString ) {
    return true, nil
}

BooleanTrueString <- ( "true" / "yes" / "on" / "t" / "y" )

BooleanFalse <- ( "FALSE" / "'" BooleanFalseString "'" / BooleanFalseString ) {
    return false, nil
}

BooleanFalseString <- ( "false" / "no" / "off" / "f" / "n" )


/*
███╗   ███╗██╗███████╗ ██████╗
████╗ ████║██║██╔════╝██╔════╝
██╔████╔██║██║███████╗██║     
██║╚██╔╝██║██║╚════██║██║     
██║ ╚═╝ ██║██║███████║╚██████╗
╚═╝     ╚═╝╚═╝╚══════╝ ╚═════╝
*/

Comment <- ( SingleLineComment / MultilineComment ) {
    return nil, nil
}

MultilineComment <- "/*" ( .* MultilineComment? .* )* "*/" EOL

SingleLineComment <- "--" [^\r\n]* EOL

EOL <-  [ \t]* ("\r\n" / "\n\r" / "\r" / "\n" / EOF)

_ "whitespace" <- [ \t\r\n]*

_1 "at least 1 whitespace" <- [ \t\r\n]+

EOF <- !.